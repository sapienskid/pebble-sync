/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => PebbleSyncPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");
var INVALID_FILENAME_CHARS = /[\\/:*?"<>|]/g;
var escapeRegExp = (value) => value.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
var sanitizeFileName = (value) => value.replace(INVALID_FILENAME_CHARS, "-").replace(/\s+/g, " ").trim();
var hashContent = (value) => {
  if (!value)
    return "0";
  let hash = 0;
  for (let i = 0; i < value.length; i++) {
    hash = Math.imul(31, hash) + value.charCodeAt(i) | 0;
  }
  return (hash >>> 0).toString(16);
};
var DEFAULT_SETTINGS = {
  // --- General Settings ---
  apiUrl: "",
  apiKey: "",
  importedKeys: [],
  maxImportedKeys: 5e3,
  // --- Automation ---
  autoRunOnStartup: false,
  autoRunInterval: 0,
  // In minutes, 0 disables
  // --- Atomic Notes ---
  atomicNotesEnabled: true,
  atomicNotesFolder: "Pebble",
  atomicNotesTags: "idea,thought",
  atomicNotesDefaultTag: "pebble",
  atomicNotesTemplate: `---
created: {{fullDateTime}}
tags: [pebble, {{tags}}]
---

{{content}}`,
  overwriteExisting: false,
  // --- Daily Note Integration ---
  linkBackToDailyNote: true,
  sectionHeading: "## Pebble Imports",
  useDailyNotesCore: true,
  dailyFolder: "",
  // Fallback
  dailyFileNameFormat: "YYYY-MM-DD"
  // Fallback
};
var PebbleSyncPlugin = class extends import_obsidian.Plugin {
  constructor() {
    super(...arguments);
    this.intervalId = null;
  }
  async onload() {
    await this.loadSettings();
    this.addRibbonIcon("sync", "Import new notes", () => this.importNow(false));
    this.addCommand({ id: "import-now", name: "Import new notes", callback: () => {
      void this.importNow(false);
    } });
    this.addCommand({ id: "force-import", name: "Force re-import (overwrite existing)", callback: () => {
      void this.importNow(true);
    } });
    this.addSettingTab(new PebbleSyncSettingTab(this.app, this));
    this.setupAutoRun();
    if (this.settings.autoRunOnStartup) {
      setTimeout(() => {
        void this.importNow(false);
      }, 2e3);
    }
  }
  onunload() {
    if (this.intervalId) {
      window.clearInterval(this.intervalId);
    }
  }
  setupAutoRun() {
    if (this.intervalId) {
      window.clearInterval(this.intervalId);
    }
    if (this.settings.autoRunInterval > 0) {
      const intervalMillis = this.settings.autoRunInterval * 60 * 1e3;
      this.intervalId = window.setInterval(() => {
        void this.importNow(false);
      }, intervalMillis);
      this.registerInterval(this.intervalId);
    }
  }
  async loadSettings() {
    const loadedData = await this.loadData();
    this.settings = Object.assign({}, DEFAULT_SETTINGS, loadedData);
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  getDailyConfig() {
    var _a, _b, _c, _d, _e, _f, _g;
    const s = this.settings;
    if (s.useDailyNotesCore && ((_c = (_b = (_a = this.app.internalPlugins) == null ? void 0 : _a.plugins) == null ? void 0 : _b["daily-notes"]) == null ? void 0 : _c.enabled)) {
      try {
        const coreConfig = (_e = (_d = this.app.internalPlugins.getPluginById("daily-notes")) == null ? void 0 : _d.instance) == null ? void 0 : _e.options;
        return {
          folder: ((_f = coreConfig == null ? void 0 : coreConfig.folder) == null ? void 0 : _f.trim()) || "",
          format: (coreConfig == null ? void 0 : coreConfig.format) || "YYYY-MM-DD",
          template: ((_g = coreConfig == null ? void 0 : coreConfig.template) == null ? void 0 : _g.trim()) || ""
        };
      } catch (e) {
        console.error("Pebble Sync: Error reading Daily Notes core config", e);
      }
    }
    return {
      folder: s.dailyFolder || "",
      format: s.dailyFileNameFormat,
      template: ""
      // Standalone mode doesn't support templates
    };
  }
  processTemplate(template, data) {
    const tagString = (data.tags || []).filter((t) => t).join(", ");
    return template.replace(/{{content}}/gi, data.content || "").replace(/{{date}}/gi, data.date || "").replace(/{{time}}/gi, data.time || "").replace(/{{fullDateTime}}/gi, data.fullDateTime || "").replace(/{{tags}}/gi, tagString);
  }
  async importNow(force = false) {
    var _a;
    const settings = this.settings;
    const apiUrl = this.normalizeApiUrl(settings.apiUrl);
    if (!apiUrl) {
      new import_obsidian.Notice("Configure a valid API URL before syncing");
      return;
    }
    if (!settings.apiKey) {
      new import_obsidian.Notice("API key is required");
      return;
    }
    if (!settings.atomicNotesEnabled) {
      new import_obsidian.Notice("Enable atomic notes to run the importer");
      return;
    }
    const targetFolder = (settings.atomicNotesFolder || "").trim();
    if (!targetFolder) {
      new import_obsidian.Notice("Set a folder for atomic notes in the settings");
      return;
    }
    const syncNotice = new import_obsidian.Notice("Fetching notes...", 0);
    const storedKeys = new Set(Array.isArray(settings.importedKeys) ? settings.importedKeys : []);
    let keysMutated = false;
    let importFailed = false;
    try {
      const response = await (0, import_obsidian.requestUrl)({
        url: `${apiUrl}/api/sync/fetch`,
        method: "GET",
        headers: {
          "Content-Type": "application/json",
          "X-API-Key": settings.apiKey
        }
      });
      const payload = (_a = response.json) != null ? _a : JSON.parse(response.text);
      const notes = Array.isArray(payload.items) ? payload.items.filter((item) => (item == null ? void 0 : item.type) === "note" && typeof item.markdown === "string") : [];
      if (notes.length === 0) {
        syncNotice.setMessage("Pebble Sync: No new notes to import.");
        return;
      }
      syncNotice.setMessage(`Pebble Sync: Importing ${notes.length} notes...`);
      await this.ensureFolder(targetFolder);
      const triggerTags = new Set((settings.atomicNotesTags || "").split(",").map((tag) => tag.trim().toLowerCase()).filter(Boolean));
      let createdCount = 0;
      let updatedCount = 0;
      let skippedDuplicates = 0;
      let skippedExisting = 0;
      for (const note of notes) {
        const dedupeKey = this.makeDedupeKey(note);
        if (!force && storedKeys.has(dedupeKey)) {
          skippedDuplicates++;
          continue;
        }
        const noteMoment = this.resolveNoteMoment(note.createdAt);
        const baseName = this.resolveBaseName(note, triggerTags);
        const relativePath = `${baseName} ${noteMoment.format("dddd, MMMM Do YYYY HH-mm")}.md`;
        const fileName = (0, import_obsidian.normalizePath)(targetFolder ? `${targetFolder}/${relativePath}` : relativePath);
        const existingFile = this.app.vault.getAbstractFileByPath(fileName);
        if (existingFile && !(settings.overwriteExisting || force)) {
          storedKeys.add(dedupeKey);
          keysMutated = true;
          skippedExisting++;
          continue;
        }
        const templateData = {
          content: note.markdown,
          date: noteMoment.format("YYYY-MM-DD"),
          time: noteMoment.format("HH:mm"),
          fullDateTime: noteMoment.format("YYYY-MM-DD HH:mm"),
          tags: note.tags || []
        };
        const fileContent = this.processTemplate(settings.atomicNotesTemplate, templateData);
        let atomicFile;
        if (existingFile instanceof import_obsidian.TFile) {
          await this.app.vault.modify(existingFile, fileContent);
          atomicFile = existingFile;
          updatedCount++;
        } else {
          atomicFile = await this.app.vault.create(fileName, fileContent);
          createdCount++;
        }
        storedKeys.add(dedupeKey);
        keysMutated = true;
        if (settings.linkBackToDailyNote) {
          await this.linkToDailyNote(atomicFile, noteMoment);
        }
      }
      if (keysMutated) {
        const maxKeys = Number.isFinite(settings.maxImportedKeys) && settings.maxImportedKeys > 0 ? settings.maxImportedKeys : DEFAULT_SETTINGS.maxImportedKeys;
        this.settings.importedKeys = Array.from(storedKeys).slice(-maxKeys);
        await this.saveSettings();
      }
      let message = "Pebble Sync: Import complete.";
      const details = [];
      if (createdCount > 0)
        details.push(`created ${createdCount} new notes`);
      if (updatedCount > 0)
        details.push(`updated ${updatedCount} notes`);
      if (skippedDuplicates > 0)
        details.push(`skipped ${skippedDuplicates} duplicates`);
      if (skippedExisting > 0)
        details.push(`skipped ${skippedExisting} existing notes`);
      if (details.length === 0) {
        message = "Pebble Sync: Nothing new to import.";
      } else {
        message += ` ${details.join(", ")}.`;
      }
      syncNotice.setMessage(message);
    } catch (error) {
      console.error("Pebble Sync import error", error);
      syncNotice.setMessage(`Pebble Sync: ${this.normalizeError(error)}`);
      importFailed = true;
    } finally {
      if (!importFailed) {
        void setTimeout(() => syncNotice.hide(), 5e3);
      }
    }
  }
  async testApiConnection() {
    const settings = this.settings;
    const apiUrl = this.normalizeApiUrl(settings.apiUrl);
    if (!apiUrl || !settings.apiKey) {
      new import_obsidian.Notice("API URL and API key must be set before testing");
      return;
    }
    const notice = new import_obsidian.Notice("Testing API connection...");
    try {
      await (0, import_obsidian.requestUrl)({
        url: `${apiUrl}/api/sync/fetch`,
        method: "GET",
        headers: {
          "Content-Type": "application/json",
          "X-API-Key": settings.apiKey
        }
      });
      notice.setMessage("API connection successful!");
    } catch (error) {
      console.error("Pebble Sync API test error", error);
      notice.setMessage(this.normalizeError(error));
    }
  }
  async linkToDailyNote(fileToLink, noteMoment) {
    var _a;
    const cfg = this.getDailyConfig();
    const dailyFileName = `${noteMoment.format(cfg.format)}.md`;
    const dailyPath = (0, import_obsidian.normalizePath)((cfg.folder ? `${cfg.folder}/` : "") + dailyFileName);
    const dailyFile = await this.ensureDailyFile(dailyPath, cfg);
    if (!dailyFile)
      return;
    const currentContent = await this.app.vault.read(dailyFile);
    const markdownLink = this.app.fileManager.generateMarkdownLink(fileToLink, dailyFile.path, "", "");
    const embedLink = `!${markdownLink}`;
    if (currentContent.includes(embedLink))
      return;
    const headingSetting = this.settings.sectionHeading.trim();
    const headingText = headingSetting.replace(/^#+\s*/, "").trim() || "Pebble Imports";
    const headingLine = headingSetting || `## ${headingText}`;
    const headingPattern = "^#+\\s+" + escapeRegExp(headingText) + "\\s*$";
    const headingRegex = new RegExp(headingPattern, "mi");
    if (headingRegex.test(currentContent)) {
      const lines = currentContent.split("\n");
      const headingIndex = lines.findIndex((line) => headingRegex.test(line));
      let insertIndex = headingIndex + 1;
      while (insertIndex < lines.length && !/^#+\s/.test(lines[insertIndex])) {
        insertIndex++;
      }
      const insertion = [embedLink];
      if (((_a = lines[insertIndex - 1]) == null ? void 0 : _a.trim()) !== "") {
        insertion.unshift("");
      }
      lines.splice(insertIndex, 0, ...insertion, "");
      await this.app.vault.modify(dailyFile, lines.join("\n"));
    } else {
      const snippet = `

${headingLine}
${embedLink}
`;
      await this.app.vault.append(dailyFile, snippet);
    }
  }
  normalizeApiUrl(rawUrl) {
    if (!rawUrl)
      return "";
    let url = rawUrl.trim();
    if (!url)
      return "";
    if (url.startsWith("app://obsidian.md/")) {
      url = `https://${url.substring("app://obsidian.md/".length)}`;
    }
    if (!/^https?:\/\//i.test(url)) {
      url = `https://${url.replace(/^\/+/, "")}`;
    }
    return url.replace(/\/+$/, "");
  }
  resolveNoteMoment(rawTimestamp) {
    const candidate = (0, import_obsidian.moment)(rawTimestamp);
    return candidate.isValid() ? candidate : (0, import_obsidian.moment)();
  }
  resolveBaseName(note, triggerTags) {
    var _a;
    const tags = new Set((note.tags || []).map((tag) => tag.replace(/^#/, "").trim().toLowerCase()));
    const matchingTag = [...triggerTags].find((tag) => tags.has(tag));
    if (matchingTag) {
      const tagName = matchingTag.charAt(0).toUpperCase() + matchingTag.slice(1);
      return sanitizeFileName(tagName) || "Pebble Note";
    }
    const defaultTag = this.settings.atomicNotesDefaultTag.trim();
    if (defaultTag) {
      const tagName = defaultTag.charAt(0).toUpperCase() + defaultTag.slice(1);
      return sanitizeFileName(tagName) || "Pebble Note";
    }
    const firstLine = (_a = (note.markdown || "").split("\n")[0]) == null ? void 0 : _a.trim();
    if (firstLine) {
      const candidate = sanitizeFileName(firstLine.substring(0, 50) || "Pebble Note");
      return candidate || "Pebble Note";
    }
    return "Pebble Note";
  }
  makeDedupeKey(note) {
    const timestamp = typeof note.createdAt === "string" ? note.createdAt : "";
    const identifier = note.id || note.uuid || note.key || "";
    const hash = hashContent(note.markdown || "");
    return [timestamp, identifier, hash].filter(Boolean).join("|");
  }
  normalizeError(error) {
    if (!error) {
      return "Unknown error during import.";
    }
    if (typeof error === "string") {
      return error;
    }
    if (typeof error === "object" && error !== null) {
      const err = error;
      if (err.response && typeof err.response === "object") {
        const response = err.response;
        const status = response.status;
        const text = response.text;
        const statusStr = typeof status === "number" ? status.toString() : "unknown";
        const preview = typeof text === "string" ? `: ${text.slice(0, 200)}` : "";
        return `API returned ${statusStr}${preview}`;
      }
      if (err.status && err.message) {
        const statusStr = typeof err.status === "number" ? err.status.toString() : "unknown";
        const messageStr = typeof err.message === "string" ? err.message : "unknown error";
        return `API returned ${statusStr}: ${messageStr}`;
      }
      if (typeof err.message === "string") {
        if (/network/i.test(err.message)) {
          return "Network error. Check your connection and URL.";
        }
        if (/unauthorized|401/i.test(err.message)) {
          return "Authorization failed. Verify your API key.";
        }
        return `Import failed - ${err.message}`;
      }
    }
    return "Import failed due to an unexpected error.";
  }
  async ensureDailyFile(path, dailyConfig) {
    let file = this.app.vault.getAbstractFileByPath(path);
    if (!file) {
      const dir = path.substring(0, path.lastIndexOf("/"));
      if (dir)
        await this.ensureFolder(dir);
      let initialContent = "";
      if (dailyConfig.template) {
        const templatePath = (0, import_obsidian.normalizePath)(dailyConfig.template + ".md");
        const templateFile = this.app.vault.getAbstractFileByPath(templatePath);
        if (templateFile instanceof import_obsidian.TFile) {
          initialContent = await this.app.vault.read(templateFile);
        }
      }
      file = await this.app.vault.create(path, initialContent);
    }
    return file instanceof import_obsidian.TFile ? file : null;
  }
  async ensureFolder(folderPath) {
    const trimmed = (folderPath || "").trim();
    if (!trimmed)
      return;
    if (!this.app.vault.getAbstractFileByPath(trimmed)) {
      await this.app.vault.createFolder(trimmed).catch(() => {
      });
    }
  }
};
var PebbleSyncSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    new import_obsidian.Setting(containerEl).setName("Sync").setHeading();
    new import_obsidian.Setting(containerEl).setName("API configuration").setHeading();
    new import_obsidian.Setting(containerEl).setName("API URL").addText((t) => t.setPlaceholder("https://pebble...").setValue(this.plugin.settings.apiUrl).onChange(async (v) => {
      this.plugin.settings.apiUrl = v.trim();
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("API key").setDesc("API key for authenticating with the sync service").addText((text) => {
      text.setPlaceholder("Enter your API key").setValue(this.plugin.settings.apiKey).onChange(async (value) => {
        this.plugin.settings.apiKey = value.trim();
        await this.plugin.saveSettings();
      });
      text.inputEl.type = "password";
    });
    new import_obsidian.Setting(containerEl).setName("Test API connection").setDesc("Click to verify that your API URL and key are working correctly").addButton((button) => {
      button.setButtonText("Test");
      button.onClick(() => {
        void this.plugin.testApiConnection();
      });
    });
    new import_obsidian.Setting(containerEl).setName("Automation").setHeading();
    new import_obsidian.Setting(containerEl).setName("Run on startup").setDesc("automatically sync when obsidian starts").addToggle((t) => t.setValue(this.plugin.settings.autoRunOnStartup).onChange(async (v) => {
      this.plugin.settings.autoRunOnStartup = v;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Automatic sync interval").setDesc("time in minutes between automatic syncs. set to 0 to disable").addText((t) => t.setPlaceholder("0").setValue(String(this.plugin.settings.autoRunInterval)).onChange(async (v) => {
      this.plugin.settings.autoRunInterval = parseInt(v, 10) || 0;
      await this.plugin.saveSettings();
      this.plugin.setupAutoRun();
    }));
    new import_obsidian.Setting(containerEl).setName("Atomic notes").setHeading();
    new import_obsidian.Setting(containerEl).setName("Create atomic notes for imports").setDesc("this must be enabled for the plugin to work").addToggle((t) => t.setValue(this.plugin.settings.atomicNotesEnabled).onChange(async (v) => {
      this.plugin.settings.atomicNotesEnabled = v;
      await this.plugin.saveSettings();
      this.display();
    }));
    if (this.plugin.settings.atomicNotesEnabled) {
      new import_obsidian.Setting(containerEl).setName("Folder for atomic notes").addText((t) => t.setPlaceholder("pebble/ideas").setValue(this.plugin.settings.atomicNotesFolder).onChange(async (v) => {
        this.plugin.settings.atomicNotesFolder = v.trim();
        await this.plugin.saveSettings();
      }));
      new import_obsidian.Setting(containerEl).setName("Trigger tags for special titles").setDesc("comma-separated list of tags that trigger special titles").addText((t) => t.setPlaceholder("idea, thought, fleeting").setValue(this.plugin.settings.atomicNotesTags).onChange(async (v) => {
        this.plugin.settings.atomicNotesTags = v;
        await this.plugin.saveSettings();
      }));
      new import_obsidian.Setting(containerEl).setName("Default tag for title").setDesc("if no trigger tags are found, use this tag for the title. if empty, the first line of the note is used").addText((t) => t.setPlaceholder("pebble").setValue(this.plugin.settings.atomicNotesDefaultTag).onChange(async (v) => {
        this.plugin.settings.atomicNotesDefaultTag = v.trim();
        await this.plugin.saveSettings();
      }));
      new import_obsidian.Setting(containerEl).setName("Atomic note template").setDesc("available variables: {{content}}, {{date}}, {{time}}, {{fullDateTime}}, {{tags}} (comma-separated string)").addTextArea((text) => {
        text.setValue(this.plugin.settings.atomicNotesTemplate).onChange(async (v) => {
          this.plugin.settings.atomicNotesTemplate = v;
          await this.plugin.saveSettings();
        });
        text.inputEl.rows = 8;
        text.inputEl.addClass("pebble-sync-textarea");
      });
      new import_obsidian.Setting(containerEl).setName("Overwrite on force re-import").setDesc("enable this to allow the force re-import command to overwrite existing notes with the same name").addToggle((t) => t.setValue(this.plugin.settings.overwriteExisting).onChange(async (v) => {
        this.plugin.settings.overwriteExisting = v;
        await this.plugin.saveSettings();
      }));
      new import_obsidian.Setting(containerEl).setName("Forget imported history").setDesc("clears the deduplication log so every note is eligible for import again").addButton((button) => {
        button.setButtonText("Clear");
        button.onClick(async () => {
          this.plugin.settings.importedKeys = [];
          await this.plugin.saveSettings();
          new import_obsidian.Notice("Import history cleared");
        });
      });
    }
    new import_obsidian.Setting(containerEl).setName("Daily note integration").setHeading();
    new import_obsidian.Setting(containerEl).setName("Embed link in daily note").setDesc("embed created atomic notes in the corresponding daily note").addToggle((t) => t.setValue(this.plugin.settings.linkBackToDailyNote).onChange(async (v) => {
      this.plugin.settings.linkBackToDailyNote = v;
      await this.plugin.saveSettings();
      this.display();
    }));
    if (this.plugin.settings.linkBackToDailyNote) {
      new import_obsidian.Setting(containerEl).setName("Section heading").setDesc("the heading to add new embeds under in your daily note").addText((t) => t.setValue(this.plugin.settings.sectionHeading).onChange(async (v) => {
        this.plugin.settings.sectionHeading = v;
        await this.plugin.saveSettings();
      }));
      new import_obsidian.Setting(containerEl).setName("Use Daily Notes core plugin").setDesc("strongly recommended. reads folder and format from the core plugin").addToggle((t) => t.setValue(this.plugin.settings.useDailyNotesCore).onChange(async (v) => {
        this.plugin.settings.useDailyNotesCore = v;
        await this.plugin.saveSettings();
        this.display();
      }));
      if (!this.plugin.settings.useDailyNotesCore) {
        new import_obsidian.Setting(containerEl).setName("Fallback folder for daily notes").addText((t) => t.setValue(this.plugin.settings.dailyFolder).onChange(async (v) => {
          this.plugin.settings.dailyFolder = v.trim();
          await this.plugin.saveSettings();
        }));
        new import_obsidian.Setting(containerEl).setName("Fallback daily note date format").addText((t) => t.setPlaceholder("YYYY-MM-DD").setValue(this.plugin.settings.dailyFileNameFormat).onChange(async (v) => {
          this.plugin.settings.dailyFileNameFormat = v.trim();
          await this.plugin.saveSettings();
        }));
      }
    }
  }
};
